# This file was generated by "rake generate_rbs"
# An implementation of https://www.ietf.org/rfc/rfc1928.txt
class SocksHandler
  PROTOCOL_VERSION: Integer
  VERSION: String

  # Socksifies all TCP connections created by TCPSocket.new or Socket.tcp
  # 
  # _@param_ `rules` — socksify a socket according to the first rule whose remote host patterns match the remote host
  # 
  # ```ruby
  # SocksHandler.socksify([
  #   # Access 127.0.0.1, ::1 or hosts that end in ".local" directly
  #   SocksHandler::DirectAccessRule.new(remote_host_patterns: %w[127.0.0.1 ::1] + [/\.local\z/]),
  # 
  #   # Access hosts that end in ".ap-northeast-1.compute.internal" through 127.0.0.1:1080
  #   SocksHandler::ProxyAccessRule.new(
  #     remote_host_patterns: [/\.ap-northeast-1\.compute\.internal\z/],
  #     socks_server: "127.0.0.1:1080",
  #   ),
  # 
  #   # Access hosts that end in ".ec2.internal" through 127.0.0.1:1081
  #   SocksHandler::ProxyAccessRule.new(
  #     remote_host_patterns: [/\.ec2\.internal\z/],
  #     socks_server: "127.0.0.1:1081",
  #   ),
  # 
  #   # Access others hosts through 127.0.0.1:1082 with username/password auth
  #   SocksHandler::ProxyAccessRule.new(
  #     remote_host_patterns: [//],
  #     socks_server: "127.0.0.1:1082",
  #     username: "user",
  #     password: ENV["SOCKS_SERVER_PASSWORD"],
  #   ),
  # ])
  # ```
  def self.socksify: (::Array[(DirectAccessRule | ProxyAccessRule)] rules) -> void

  def self.desocksify: () -> void

  # _@param_ `host` — a domain name or IP address of a remote host
  def self.find_rule: (String host) -> (DirectAccessRule | ProxyAccessRule)?

  # _@param_ `socket` — a socket that has connected to a socks server
  # 
  # _@param_ `remote_host`
  # 
  # _@param_ `remote_port` — a port number or service name such as "http"
  # 
  # _@param_ `username`
  # 
  # _@param_ `password`
  def self.establish_connection: (
                                   (Socket | TCPSocket) socket,
                                   String remote_host,
                                   (Integer | String) remote_port,
                                   ?String? username,
                                   ?String? password
                                 ) -> void

  def self.rules: () -> ::Array[(DirectAccessRule | ProxyAccessRule)]

  # _@param_ `socket`
  # 
  # _@param_ `username`
  # 
  # _@param_ `password`
  def self.negotiate: ((Socket | TCPSocket) socket, String? username, String? password) -> void

  # _@param_ `socket`
  # 
  # _@param_ `username`
  # 
  # _@return_ — code of authentication method
  def self.choose_auth_method: ((Socket | TCPSocket) socket, String? username) -> Integer

  # _@param_ `socket`
  # 
  # _@param_ `remote_host`
  # 
  # _@param_ `remote_port`
  def self.send_connect_request: ((Socket | TCPSocket) socket, String remote_host, Integer remote_port) -> void

  # @!attribute [r] host
  #   @return [String, nil]
  # @!attribute [r] port
  #   @return [Integer, nil]
  # @!attribute [r] username
  #   @return [String, nil]
  # @!attribute [r] password
  #   @return [String, nil]
  # @!attribute [r] remote_host_patterns
  #   @return [Array<String, Regexp>]
  class Rule
    # sord omit - no YARD type given for "**kwargs", using untyped
    def self.new: (**untyped kwargs) -> Rule

    # _@param_ `remote_host_patterns`
    # 
    # _@param_ `host`
    # 
    # _@param_ `port`
    # 
    # _@param_ `username`
    # 
    # _@param_ `password`
    def initialize: (
                      remote_host_patterns: ::Array[(String | Regexp)],
                      ?host: String?,
                      ?port: Integer?,
                      ?username: String?,
                      ?password: String?
                    ) -> void

    def direct: () -> bool

    # _@param_ `remote_host`
    def match?: (String remote_host) -> bool

    # _@param_ `value`
    def convert_regexps: (::Array[(String | Regexp)] value) -> ::Array[Regexp]

    attr_reader host: String?

    attr_reader port: Integer?

    attr_reader username: String?

    attr_reader password: String?

    attr_accessor remote_host_patterns: ::Array[(String | Regexp)]
  end

  class UnsupportedProtocol < StandardError
  end

  class NoAcceptableMethods < StandardError
  end

  class AuthenticationFailure < StandardError
  end

  class RelayRequestFailure < StandardError
    # _@param_ `code`
    def initialize: (Integer code) -> void
  end

  module Command
    CONNECT: Integer
    BIND: Integer
    UDP_ASSOCIATE: Integer
  end

  module AddressType
    IPV4: Integer
    DOMAINNAME: Integer
    IPV6: Integer
  end

  module SocketSocksify
    # _@param_ `remote_host`
    # 
    # _@param_ `remote_port`
    # 
    # _@param_ `local_host`
    # 
    # _@param_ `local_port`
    # 
    # _@param_ `connect_timeout`
    # 
    # _@param_ `resolv_timeout`
    # 
    # _@return_ — (The actual type is Socket and IO is just for avoiding RBS::NoTypeFoundError)
    def tcp: (
               String remote_host,
               (Integer | String) remote_port,
               ?String? local_host,
               ?(Integer | String)? local_port,
               ?connect_timeout: (Integer | Float)?,
               ?resolv_timeout: (Integer | Float)?
             ) -> IO
  end

  class ProxyAccessRule < SocksHandler::Rule
    # _@param_ `remote_host_patterns`
    # 
    # _@param_ `socks_server` — a string in the format "<host>:<port>"
    # 
    # _@param_ `username`
    # 
    # _@param_ `password`
    def initialize: (
                      remote_host_patterns: ::Array[(String | Regexp)],
                      socks_server: String,
                      ?username: String?,
                      ?password: String?
                    ) -> void

    def direct: () -> bool
  end

  class DirectAccessRule < SocksHandler::Rule
    # _@param_ `remote_host_patterns`
    def initialize: (remote_host_patterns: ::Array[(String | Regexp)]) -> void

    def direct: () -> bool
  end

  module TCPSocketSocksify
    # _@param_ `remote_host`
    # 
    # _@param_ `remote_port`
    # 
    # _@param_ `local_host`
    # 
    # _@param_ `local_port`
    # 
    # _@param_ `connect_timeout`
    def initialize: (
                      String remote_host,
                      (Integer | String) remote_port,
                      ?String? local_host,
                      ?(Integer | String)? local_port,
                      ?connect_timeout: (Integer | Float)?
                    ) -> void
  end

  module AuthenticationMethod
    NONE: Integer
    GSSAPI: Integer
    USERNAME_PASSWORD: Integer
  end

  # An implementation of https://www.ietf.org/rfc/rfc1929.txt
  class UsernamePasswordAuthenticator
    SUBNEGOTIATION_VERSION: Integer

    # _@param_ `username`
    # 
    # _@param_ `password`
    def initialize: (String username, String password) -> void

    # _@param_ `socket` — (The actual type is Socket, TCPSocket and IO is just for avoiding RBS::NoTypeFoundError)
    def authenticate: (IO socket) -> void
  end
end